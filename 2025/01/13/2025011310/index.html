<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>当输入一个 URL，实际会发生什么？ | 避凉闲庭</title><meta name="author" content="避凉闲庭"><meta name="copyright" content="避凉闲庭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从一个经典的面试题说起从输入URL到页面展现的过程:"><meta property="og:type" content="article"><meta property="og:title" content="当输入一个 URL，实际会发生什么？"><meta property="og:url" content="https://blxtcloud.github.io/2025/01/13/2025011310/index.html"><meta property="og:site_name" content="避凉闲庭"><meta property="og:description" content="从一个经典的面试题说起从输入URL到页面展现的过程:"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg"><meta property="article:published_time" content="2025-01-13T06:17:18.000Z"><meta property="article:modified_time" content="2025-01-18T13:14:26.287Z"><meta property="article:author" content="避凉闲庭"><meta property="article:tag" content="技术笔记"><meta property="article:tag" content="云计算"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "当输入一个 URL，实际会发生什么？",
  "url": "https://blxtcloud.github.io/2025/01/13/2025011310/",
  "image": "https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg",
  "datePublished": "2025-01-13T06:17:18.000Z",
  "dateModified": "2025-01-18T13:14:26.287Z",
  "author": [
    {
      "@type": "Person",
      "name": "避凉闲庭",
      "url": "https://blxtcloud.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://jihulab.com/blxt/images/-/raw/main/ico/favicon.ico"><link rel="canonical" href="https://blxtcloud.github.io/2025/01/13/2025011310/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!0},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:150,languages:{author:"作者: 避凉闲庭",link:"链接: ",source:"来源: 避凉闲庭",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"当输入一个 URL，实际会发生什么？",isHighlightShrink:!1,isToc:!0,pageType:"post"},imgurl="https://jihulab.com/blxt/images/-/raw/main/"</script><link rel="stylesheet" href="/css/external.css"><link rel="stylesheet" href="/css/downloads.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg" onerror='this.onerror=null,this.src="https://jihulab.com/blxt/images/-/raw/main/ico/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house-chimney"></i> <span>首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-graduation-cap"></i> <span>学习</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/python/"><i class="fa-fw fa-brands fa-python"></i> <span>python</span></a></li><li><a class="site-page child" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"><i class="fa-fw fa-solid fa-cloud"></i> <span>云计算</span></a></li><li><a class="site-page child" href="/categories/php/"><i class="fa-fw fa-brands fa-php"></i> <span>php</span></a></li><li><a class="site-page child" href="/categories/%E5%AE%89%E5%85%A8/"><i class="fa-fw fa-solid fa-user-secret"></i> <span>安全</span></a></li><li><a class="site-page child" href="/categories/linux/"><i class="fa-fw fa-brands fa-linux"></i> <span>linux</span></a></li><li><a class="site-page child" href="/categories/%E5%B0%8F%E8%AE%B0/"><i class="fa-fw fa-solid fa-pen"></i> <span>小记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/downloads/"><i class="fa-fw fa-solid fa-cloud-arrow-down"></i> <span>资源下载</span></a></div><div class="menus_item"><a class="site-page" href="/identity/"><i class="fa-fw fa-solid fa-address-card"></i> <span>个人简介</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa-solid fa-message"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-link"></i> <span>推荐链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">避凉闲庭</span></a><a class="nav-page-title" href="/"><span class="site-name">当输入一个 URL，实际会发生什么？</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-solid fa-house-chimney"></i> <span>首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-graduation-cap"></i> <span>学习</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/python/"><i class="fa-fw fa-brands fa-python"></i> <span>python</span></a></li><li><a class="site-page child" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"><i class="fa-fw fa-solid fa-cloud"></i> <span>云计算</span></a></li><li><a class="site-page child" href="/categories/php/"><i class="fa-fw fa-brands fa-php"></i> <span>php</span></a></li><li><a class="site-page child" href="/categories/%E5%AE%89%E5%85%A8/"><i class="fa-fw fa-solid fa-user-secret"></i> <span>安全</span></a></li><li><a class="site-page child" href="/categories/linux/"><i class="fa-fw fa-brands fa-linux"></i> <span>linux</span></a></li><li><a class="site-page child" href="/categories/%E5%B0%8F%E8%AE%B0/"><i class="fa-fw fa-solid fa-pen"></i> <span>小记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/downloads/"><i class="fa-fw fa-solid fa-cloud-arrow-down"></i> <span>资源下载</span></a></div><div class="menus_item"><a class="site-page" href="/identity/"><i class="fa-fw fa-solid fa-address-card"></i> <span>个人简介</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fa-solid fa-message"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa-solid fa-link"></i> <span>推荐链接</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">当输入一个 URL，实际会发生什么？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-13T06:17:18.000Z" title="发表于 2025-01-13 14:17:18">2025-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-18T13:14:26.287Z" title="更新于 2025-01-18 21:14:26">2025-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h2 id="从一个经典的面试题说起"><a href="#从一个经典的面试题说起" class="headerlink" title="从一个经典的面试题说起"></a>从一个经典的面试题说起</h2><p>从输入URL到页面展现的过程:</p><span id="more"></span><ol><li>输入URL后，会先进行域名解析。优先查找本地host文件有无对应的IP地址，没有的话去本地DNS服务器查找，还不行的话，本地DNS服务器会去找根DNS服务器要一个域服务器的地址进行查询，域服务器将要查询的域名的解析服务器地址返回给本地DNS，本地DNS去这里查询就OK了。</li><li>浏览器拿到服务器的IP地址后，会向它发送HTTP请求。HTTP请求经由一层层的处理、封装、发出之后，最终经由网络到达服务器，建立TCP&#x2F;IP连接，服务器接收到请求并开始处理。</li><li>服务器构建响应，再经由一层层的处理、封装、发出后，到达客户端，浏览器处理请求。</li><li>浏览器开始渲染页面，解析HTML，构建render树，根据render树的节点和CSS的对应关系，进行布局，绘制页面。</li></ol><p>这4个步骤包含了一个HTTP请求的完整生命周期，文章着重介绍第2步和第3步，也就是请求是如何在两个物理端点之间进行通信的。数据的发出和接收必然会经历一些处理、解析的过程，这些过程在系统的不同层次进行。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>一个HTTP请求从源端发出到在终端接收的处理过程都是要经过以下四层。其中每一层都有各自的协议。</p><script>document.write('<img src="'+imgurl+'1736749038/28c13e41b8db6dbbc737deaa0d664896.jpeg">')</script><br><p>我们先来理解一下协议是什么，协议是经过约定，双方共同承认，并且需要共同遵守的规则。上面的每一层，都有各自的协议，协议的执行者是通信链路两端内的对应层。每一层通过协议来理解数据，并进行处理。</p><p>上图中只举例出了最常见的协议，实际上每一层都有细分的协议：</p><ul><li>应用层：应用程序负责将数据以相应规则（协议）进行包装，发给传输层<ul><li>HTTP：超文本传输协议</li><li>FTP：文件传输协议</li><li>SMTP：简单邮件传送协议</li><li>SNMP：简单网络管理协议</li></ul></li><li>传输层：负责将应用层传过来的数据进行分组，为确保终端接收数据的顺序和完整性，会对每个分组进行标记，交给网络层<ul><li>TCP：传输控制协议</li><li>UDP：用户数据协议</li></ul></li><li>网络层：负责将传输层发来的数据分组发送到目标终端<ul><li>IP：网际协议</li><li>ICMP：Internet互联网控制报文协议</li><li>IGMP：Internet组管理协议</li></ul></li><li>链路层：为网络层发送和接收数据单元<ul><li>ARP：地址解析协议</li><li>RARP：逆地址解析协议</li></ul></li></ul><h2 id="封装和分用"><a href="#封装和分用" class="headerlink" title="封装和分用"></a>封装和分用</h2><p>数据在经过每一层的时候都要被对应的协议包装，到达终端的时候，要一层一层的解包。这两个过程叫封装和分用。</p><p>发送时，用户数据被HTTP封装为报文，每一层会将上层传过来的报文作为本层的数据块，并添加自己的首部，其中包含了协议标识，这一整体作为本层报文向下传递。</p><p>接收时，数据自下而上流动，经过每一层时被去掉报文首部，根据报文标识确定正确的上层协议，最终到应用层被应用程序处理。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>源端发送HTTP报文时，报文会以数据流的形式通过一条已经打开的TCP连接按序传输，TCP收到数据流后会将其分割成小的数据块，每个小块被添加的TCP首部与数据块共同组成了TCP分组，分组经由网络层发送，网络层遵循IP协议，当收到分组发送请求后，会将分组其放入IP数据报，填充报头，将数据报发经由链路层发送出去。</p><script>document.write('<img src="'+imgurl+'1736749038/1de02df81aa591dae332c7142457a9a6.jpeg">')</script><br><p>这一过程经过每层的时候都会被增加一些首部信息，有时还需要增加尾部信息，每一层都会把数据封装到各自的报文中， 并在报文首部添加协议标识，这个过程叫<strong>封装</strong>。</p><h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p>终端接收到一个以太网数据帧时，数据自底层向上流动，去掉发送时各层协议加上的报文首部，每层协议都要检查报文首部的协议标识，从而确定上层协议，保证数据被正确处理，这个过程叫分用。</p><script>document.write('<img src="'+imgurl+'1736749038/08feeaac386b56b1484eba3aa83f6f69.jpeg">')</script><br><p>终端从链路层接收到数据请求后，进入网络层对数据进行解析，交给给传输层，校验分组顺序和完整性，从数据块中取出数据，得到HTTP报文，交给应用层进行处理。这个过程会逐层剥离报头还原数据。</p><h2 id="逐层分析"><a href="#逐层分析" class="headerlink" title="逐层分析"></a>逐层分析</h2><p>我们已经知道，数据是从源端自上而下到终端自下而上被一层层处理的，现在就来看一下每层都做了什么事情。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP属于应用层，用户触发交互所产生的行为数据和服务端对此的响应都由它封装成HTTP报文，再交由下层协议进行处理。报文的作用是客户端与服务端沟通的载体，双方都要遵循统一规则对信息进行处理，这一规则称为HTTP。</p><p>客户端与服务端的交互往往非常复杂，为了使双方都能高效、明确、安全地通信（例如传递意图与状态、承载数据、携带认证信息、控制连接行为与缓存），需要依赖报文中的结构来实现，下面先从结构开始看。</p><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>HTTP报文的结构分为请求和响应两种，请求报文封装用户操作产生的动作，告知服务器应采取什么行为，响应报文来告知客户端请求的结果。<br>请求报文格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">request-url</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span> // 起始行格式</span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span> // 首部</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> // 实体</span><br></pre></td></tr></table></figure><p>响应报文格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">status</span>&gt;</span> <span class="tag">&lt;<span class="name">reason-phrase</span>&gt;</span> // 起始行格式</span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span> // 首部</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> // 实体</span><br></pre></td></tr></table></figure><h2 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h2><p>报文的起始行表明了报文的开始，请求和响应各自的起始行的格式也不相同。</p><p>请求报文的起始行说明要做什么，结构为方法 + 请求URL + 协议版本，中间用空格做分隔：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /api/nht/blog/example HTTP/1.1</span><br></pre></td></tr></table></figure><p>响应报头的起始行说明发生了什么，结构为协议版本 + 状态码 + 描述文本，中间用空格做分隔：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><h2 id="方法与状态码"><a href="#方法与状态码" class="headerlink" title="方法与状态码"></a>方法与状态码</h2><p>方法来告诉服务端请求报文要做的事情，状态码来通知客户端服务端依据请求报文完成动作之后的大致结果。常见的HTTP方法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 方法 | 含义 | 有无主体 | | ------- | ---------------------------------------------- | -------- | | GET | 从服务端获取资源 | 无 | | HEAD | 只获取资源头部 | 无 | | POST | 向服务端发送数据 | 有 | | PUT | 将客户端发送的数据存到服务端，应用场景多为修改 | 有 | | OPTIONS | 对服务端进行预检，例如服务端支持哪些方法 | 无 | | DELETE | 从服务端删除资源 | 无 |</span><br><span class="line"></span><br><span class="line">请求完成时，响应报文中会有一个状态码，用来表示此次请求的状态，是成功了还是失败了，或者时需要重定向。状态码的范围从100到599， 其中有部分是已经定义的。不同的范围表示的含义也不同：</span><br><span class="line"></span><br><span class="line">| 范围 | 已定义范围 | 含义 | | ------- | ---------------------------------------------- | ---------- | | 100~199 | 100~101 | 信息提示 | | 200~299 | 200~206 | 成功 | | 300~399 | 300~305 | 重定向 | | 400~499 | 400~415 | 客户端错误 | | 500~599 | 500~505 | 服务端错误 |</span><br></pre></td></tr></table></figure><h2 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h2><p>首部是请求和响应报文中的一些信息，形式为键值对，每对键值结尾是CRLF换行符，它决定了请求或者响应报文的属性，比如Content-Type表明了请求主体的数据类型，Date说明了请求的创建时间。客户端与服务端通过首部来协商具体行为。可以根据请求、响应、结构等，将首部分为五种。</p><ul><li>请求首部：是放在请求报文中的首部，它被用来告诉服务端一些信息。</li><li>响应首部：为客户端提供一些可能用到的信息。</li><li>通用首部：请求与响应报文都包含的首部，例如Date首部</li><li>实体首部：对于报文实体主体部分的描述，比如Content-Type，表明其数据类型。</li><li>扩展首部：开发者自己添加的首部字段，用来满足定制化需求。</li></ul><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: xxxxxxx</span><br><span class="line">Date: Sun,17 Sep 2019 02:01:16 GMT</span><br><span class="line">--------------------------------实体首部</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-length: 18</span><br><span class="line">--------------------------------实体主体</span><br><span class="line"></span><br><span class="line">Hi! I&quot;m a message!</span><br><span class="line">--------------------------------</span><br></pre></td></tr></table></figure><p>实体部分是可选的，它被用来运送请求或者响应的数据，实体由实体首部 + 实体主体组成，实体首部对实体主体做描述。HTTP&#x2F;1.1定义了以下的基本实体首部字段：</p><ul><li>Content-Type: 实体主体中的数据类型。</li><li>Content-Length: 实体主体的长度或者大小。</li><li>Content-Language: 和传输的数据最匹配的语言。</li><li>Content-Encoding: 来标识服务端编码时所用的编码方式。</li><li>Content-Location: 要返回的数据的地址。</li><li>Content-Range: 如果是部分实体，用来标记它是实体的哪个部分。</li><li>Content-MD5: 实体主体内容的校验和。</li><li>Last-Modified: 所传输内容在服务器上创建或者最后修改的日期时间。</li><li>Expires: 实体数据试下的日期时间。</li><li>Allow: 所请求资源允许的请求方法。</li><li>ETag: 资源的特定版本的标识符。可以让缓存更高效，并节省带宽。</li><li>Cache-Control: 控制缓存机制的指令。</li></ul><p>以上是HTTP报文包含的主要结构，当请求报文到达服务器时，服务器会对报文中的内容解析出来，根据方法、资源路径、首部、和主体来处理请求，然后通过对请求资源的访问结果，来构建响应，回送给客户端。</p><h2 id="传输层-TCP"><a href="#传输层-TCP" class="headerlink" title="传输层-TCP"></a>传输层-TCP</h2><p>HTTP连接是建立在TCP连接的基础之上的，TCP提供可靠的数据连接。当要传输一个HTTP报文时，报文数据会以流的形式通过一条已经打开的TCP连接按顺序传输，TCP会将收到的数据分成小块，每块是一个TCP分组。</p><p>由于数据是分成小块发送的，所以完整可靠的数据传输主要体现在：分组是否完整、分组顺序是否正常、分组是否损坏、分组数据是否重复。这些可以通过TCP的检验和、序列号、确认应答、重发控制、连接管理和窗口机制来控制。</p><p>TCP是传输控制协议，传输控制主要依赖首部包含的6个标志，它们控制报文的传输状态，以及发送端和接收端应对数据采取的动作。当它们的值为1时，标志对应的各自功能才允许被执行，比如当URG为1时，报文首部的紧急指针部分才有效。</p><ul><li>URG 紧急指针</li><li>ACK 确认序号有效</li><li>PSH 接收方应该尽快将这个报文段交给应用层。</li><li>RST 重建连接</li><li>SYN 同步序号用来发起一个连接</li><li>FIN 发端完成发送任务<script>document.write('<img src="'+imgurl+'1736749038/16b46ed733bf98601210dec418d1ef75.jpeg">')</script><br></li></ul><p>源端口和目的端口：标识发送方和接收方的端口号，一个TCP连接通过4个值确认：源IP、源端口、目的IP、目的端口，其中源IP和目的IP包含在IP分组内。</p><p>首部长度：表示TCP首部的字节长度，也能标记出从多少个字节开始，才是需要传输的数据。</p><p>TCP段序号：本段报文发送的数据第一个字节的序号，每段报文中的数据的每个字节都有序号，第一个字节的序号从0开始，依次加1，加到2的32次方减1后再次从0开始。</p><p>TCP段确认序号 ：当首部标志ACK为1时，确认序号有效。TCP段被接收端接收后，会回送给发送端一个确认号，为上次接受的最后一个字节序号加1。</p><p>检验和：由发送端计算，接收端验证，如果接收方检测到检验和不正确，表明该TCP段可能有损坏，会被丢弃，同时接收端向回送一个重复的确认号（与最近的一次正确的报文传输的确认号重复），表明接收到的TCP段是错误的，并告知自己希望收到的序号。这时发送端需要立即重传出错的TCP段。</p><p>紧急指针：当首部标志URG为1时，紧急指针有效，表示发送端向接收端要发送紧急数据。紧急指针是一个正偏移量，它和TCP段序号相加，计算出紧急数据的最后一个字节的序号。比如接收方接收到数据，从序号为1000的字节开始读取，紧急指针为1000，那么紧急数据就是序号从1000到2000之间的字节。这些数据由接收方决定如何处理。</p><p>窗口尺寸：决定了TCP一次成块数据流的吞吐量。需要注意的是，它表示的是发送一方的允许对方发送的数据量，比如发送方首部中的窗口大小为1000，就表示发送方最多可以接受对方发来的1000个字节的数据量。这与发送方的数据缓存空间有关，会影响TCP的性能。</p><p>首部标志PSH：如果需要告诉接收方将数据立即全部提交给接收进程，发送方需要将PSH置为1，这里的数据是和PSH一起传送的数据以及之前接收到的全部数据。如果接收方收到了PSH为1的标志，需要立即将数据提交给接收进程，不用再等待有没有其他数据进来。</p><p>复位标志RST：当RST为1时，表示连接出现了异常情况，接收方将终止连接，通知应用层重新建立连接。</p><p>同步序号SYN：用来建立连接，涉及到TCP的三次握手。</p><ol><li>开始建立连接时，客户端向服务器发送一个TCP分组，分组首部的SYN为1，并携带一个初始序号，表明这是一个连接请求。</li><li>如果服务器接受了连接，会向客户端发送一个TCP分组，分组中会包含SYN和ACK，都为1，同时包含一个确认序号，值为来自客户端的初始序号 + 1，表示连接已经被接受。</li><li>客户端收到上一步发来的分组后，会再向服务器发送一段确认报文分组，ACK为1，会再次携带确认序号，值是第二步来自客户端的确认序号 +1。服务端收到确认信息后，进入已经连接的状态。<br>在第三步的确认分组中，是可以携带要发送的数据的。</li></ol><p>连接终止标志FIN：用来关闭连接，当一端完成数据发送任务后会发送一个FIN标志来终止连接，但因为TCP在两个方向（C-S,S-C）上会有数据传递，每个方向有各自的发送FIN &amp; 确认关闭流程，所以会有四次交互，也称为四次挥手。</p><ol><li>如果客户端应用层的数据发送完毕，会导致客户端的TCP报文发送一个FIN，告知服务器准备关闭数据传送。</li><li>服务器接收到这个标志后，它发回一个ACK，确认序号为收到的序号加1，同时TCP还要向应用程序发一个文件结束符。</li><li>此时服务器关闭这个方向的连接，导致它的TCP也会发送一个FIN。</li><li>客户端接收到之后发回一个确认ACK，序号为收到的序号 + 1，连接完全关闭。</li></ol><p>TCP段序号与确认序号保证了数据的顺序，检验和确保数据的完整性，紧急指针保证紧急数据可被及时处理。另外，TCP还有一些超时重传、 拥塞避免、慢启动的机制，都可以保证分组数据按照顺序完整的传到目标端。</p><h2 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层-IP"></a>网络层-IP</h2><p>如果说TCP分组是包装货物的集装箱，那么IP就是运送集装箱的卡车。IP协议提供了两个节点之间的连接，保证将TCP数据尽可能快地从源端送到终端，但却不能保证传输的可靠性。</p><p>IP层会将上层传过来的TCP分组封装，带上自己的首部，再进行选路、是否分片以及重组的工作，最终到达目的地，这个过程中，IP首部起了重要的作用，下面让我们看一下首部的结构。</p><script>document.write('<img src="'+imgurl+'1736749038/a5f3a2b38bac4db9dc02e1192dea09b0.jpeg">')</script><br><p><strong>版本：</strong>表示当前IP协议的版本，目前版本号是4，还有一种是6，也就是IPV4和IPV6，如果发送和接收这两端的版本不一致，那么当前IP数据报会被丢弃。</p><p><strong>首部长度：</strong>整个首部的长度，最长为60字节。</p><p><strong>服务类型（TOS）：</strong>用来区分服务的类型，但其实IP层在工作的时候一直没有实际使用过，现有的TOS只有4bit的子字段，和1bit的未用位。未用位必须置为0。TOS的4个bit中只能将一个置成1，用来表示当前服务类型。4bit对应的4个服务类型分别为：最小时延、最大吞吐量、最高可靠性和最小费用。</p><p><strong>总长度：</strong>表示当前的数据报报文的总长度，单位为字节，可以结合首部长度计算出报文内数据的大小以及起始位置。</p><p>下面这三个首部字段涉及到IP数据报的分片与重组过程，由于网络层一般会限制每个数据帧的最大长度，IP层发送数据报会在选路的同时查询当前设备网络层的每个数据帧的最大传输长度，一旦超出，数据报就会被进行分片，到达目的地之后再进行重组，此时就会用以下三个字段作为重组依据。需要注意的是：因为存在选路的过程，数据报经过的每层路由设备对于数据帧的最大传输长度都不同，所以分片可能发生在任意一次选路的过程中。</p><p><strong>分组标识：</strong>这个标识相当于ID，每成功发送一个分片，IP层就会把这个分组ID加1。</p><p><strong>标志：</strong>共占用三位，分别是R、D、M，R目前还没有被使用，有用的是D、和M。这个字段表示了数据报的分片行为。D如果为1的话，表示数据无需分片，一次传输完；M如果为1，表示数据是分片的，后边还有数据，当它为0时，就表示当前数据报是最后一个分片，或者只有这一个分片。</p><p><strong>片偏移：</strong>标识了当前分片距离原始数据报开始处的位置，分片之后，每一片的总长度会改成这一片的长度值，而不是整个数据报的长度。</p><p><strong>生存时间：</strong>（TTL） 可以决定数据报是否被丢弃。因为IP发送数据是逐跳的，数据有可能在被设置了路由功能的不同的IP层之间转发，所以生存时间表示了数据报最多个可以经过多少个处理过它的路由，每经过一层路由，值减去1，当值为0时数据报就被丢弃，并且发送一个带有错误消息的报文（ICMP，IP层的组成部分，被用来传递一些错误信息）给源端。生存时间可以有效解决数据报在一个路由环路中一直转发的问题。</p><p><strong>首部检验和：</strong>校验数据报的完整性，发送端对首部进行求和，将结果存在检验和中，接收端再计算一遍，如果计算结果与存在检验和中的结果一致，则说明传输过程是OK的，否则这个数据报就会被丢弃。<br>上层协议：决定了接收端在分用的时候将数据交给哪个上层协议去处理，例如TCP或者UDP。</p><p><strong>源IP：</strong>记录了发送端的IP，在回送错误消息时用到。</p><p><strong>目的IP：</strong>表示目的IP，每一次选路都要以它来做决策。</p><h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><p>因为IP首部只包含了目的IP地址，并不体现完整的路径，当向外发送数据时，IP层会根据目的IP在本机路由表中的查询结果来做出选路决策，数据报会逐跳地被运送到目的地，这里的每一跳，就是一次路由选择。</p><p>IP层既可配置成路由器，也可以配置成主机。当配置成路由功能时，可以对数据报进行转发，配置成主机时，如果目的IP不是本机IP，数据报会被丢弃。</p><p>具有路由功能的IP层在当目标IP不是本机地址的时候是根据什么判断转发到哪一站呢？要理解这个问题，需要先明白路由表的结构，以下是IP层维护的路由表，（windows系统可以在控制台输入netstat -r来查看路由表）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| Destination | Gateway | Flags| Refcnt| Use | Interface| | ------------------ | --------------- | -----|------ |---- | ---------| | 140.252.13.65</span><br></pre></td></tr></table></figure><ul><li>Destination（目的IP）：表示IP数据报最终要到达或者经过的网络地址或者主机地址。</li><li>Gateway（下一跳地址）：当前维护路由表设备的相邻路由器的地址</li><li>Flags（标志）：表示当前这一条路由记录的属性，具体用五个不同的标志来表示：<ul><li>U：该路由可以使用</li><li>G：如果有这个标志，表示是下一跳是一个网关，如果没有，表示下一跳是和当前设备在一个网段，也就是可以直接把数据报发过去</li><li>H: 下一跳是一个主机还是一个网络，有这个标志，表示主机，没有，则表示下一跳的路由是一个网络</li><li>D：该路由是由重定向报文创建的</li><li>M：该路由已被重定向报文修改</li><li>Interface：当前路由项的物理端口</li></ul></li></ul><p>每收到一个数据报时候，IP层就会根据目的IP在路由表里查询，根据查询状态会导向三种结果：</p><ol><li>找到了与目的IP完全匹配的路由项，将报文发给该路由项的下一站路由（Gateway）或者网络接口（Interface）</li><li>找到了与目的IP的网络号匹配的路由项，将报文发给该路由项的下一站路由（Gateway）或者网络接口（Interface）</li><li>前两者都没有找到，就看路由表里有没有默认路由项（default），有的话发给它指定的下一站路由（Gateway）</li></ol><p>要是上边三个都没有结果，那么数据报就不能被发送。IP数据报就是这样一跳一跳地被送往目的主机的，但数据报有固有的长度，一旦超出了目的主机的MTU，就会被分片。</p><h2 id="数据报分片的概念"><a href="#数据报分片的概念" class="headerlink" title="数据报分片的概念"></a>数据报分片的概念</h2><p>TCP在进行握手的时候，会根据目的端IP层的最大传输单元（MTU）来决定TCP数据每次能传输的最大数据量（MSS），之后TCP会对数据依照MSS来进行分组，每个分组会被包装进一个IP数据报内。当IP数据报经过选路过程中的任意一层路由时，有可能被MTU限制住从而被分片，这时IP首部的3bit标志中的M标志被置为1，表示需要分片。每个分片的首部基本一样，只是片偏移有所不同。依据片偏移，这些分片在目的端被重组成一个完整的IP数据报（一个TCP分组）。IP传输是无序的，所以得到的数据报也是无序的，但如果数据完整，TCP会根据首部中的字段对其进行排序。一旦IP分片丢失，IP层无法组成完整的数据报，就会告诉TCP层，TCP进行重传。</p><p>当IP层将数据封装好之后，只有目标主机的IP地址。光有IP地址并不能直接把数据报发送过去，因为每一台硬件设备都有自己的MAC地址，是一个48bit的值。现在知道目标IP的地址，需要找到这个IP对应的MAC地址。这个过程要通过查询路由表，再结合链路层的ARP协议，最终获得目标IP对应的MAC地址。</p><h2 id="地址解析协议：ARP"><a href="#地址解析协议：ARP" class="headerlink" title="地址解析协议：ARP"></a>地址解析协议：ARP</h2><p>IP只能让数据在逻辑端点之间流动，但是IP之下还有网络接口层，这一层也有自己的地址（MAC地址：用于在网络中唯一标识一个网卡），从IP地址到MAC地址需要一个转换的过程，ARP就是提供这一服务的。</p><p>ARP协议实现了从IP地址到MAC地址的映射。一开始，起点并不知道目标的MAC地址，只有目标IP，要获取这个地址就涉及到了ARP的请求和应答。同样，ARP也有自己的分组，先看一下分组格式。</p><h2 id="ARP分组格式"><a href="#ARP分组格式" class="headerlink" title="ARP分组格式"></a>ARP分组格式</h2><script>document.write('<img src="'+imgurl+'1736749038/275aa1fb202513a910a06fb5ff2db19d.jpeg">')</script><br><p>以太网目的地址：目的端的MAC地址，当ARP缓存表中没有的时候，这里为广播地址。</p><p>以太网源地址：发送端的MAC地址。</p><p>帧类型：不同的帧类型有不同的格式和MTU值，不同的类型有不同的编号，这里ARP对应的编号是0x0806。</p><p>硬件类型：指链路层网络类型，1为以太网。</p><p>协议类型：指的是要转换的地址类型，0x0800为IP地址。比如将以太网地址转换为IP地址。</p><p>op（操作类型）：有四种，分别是ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。</p><p>源MAC地址：表示发送端MAC地址。</p><p>源IP地址：表示发送端IP地址。</p><p>目的以太网地址：表示目标设备的MAC物理地址。</p><p>目的IP地址：表示目标设备的IP地址。</p><p>当两台设备发送报文之前，源端的链路层会用ARP协议去询问目的端的MAC地址，ARP会将一个请求广播出去，以太网上的每一个主机都会收到这份广播，广播的目的是询问目标IP的MAC地址，内容主要是先介绍自己的IP和MAC地址，再询问如果你有目标IP，请回复你的硬件地址。如果一个主机收到广播后看到自己有这个IP，并且请求内有源IP和MAC地址，那么就会向源主机回应一个ARP应答。如果没有目标IP，就会丢弃这个请求。可以看出请求是向外广播的，而应答是单独回应的。</p><p>但不能每次通信之前都去经历一次请求-应答过程，在成功地接收到应答之后，IP和MAC地址的映射关系就会缓存在ARP缓存表中，有效期一般为20分钟，便于网络层下次直接进行封装，所以，完整的过程应该是：<br>IP层接收到TCP分组后，发送或者封装之前，通过查询路由表：</p><ol><li>当目标IP和自己在同一个网段时，先去ARP缓存表里找有没有目标IP对应的MAC地址，有的话交给链路层进行封装发送出去。如果缓存表内没有，进行广播，获得MAC地址后缓存起来，IP层再对TCP进行封装，然后交给链路层再封装发送出去。</li><li>当目标IP和自己不在同一个网段，需要将报文发给默认的网关。如果ARP缓存表中有网关IP对应的MAC地址，那么交给链路层进行封装发送出去。如果没有，进行广播，获得地址后缓存起来，IP层再对TCP进行封装，然后交给链路层再封装发送出去。</li></ol><h2 id="以太网数据帧"><a href="#以太网数据帧" class="headerlink" title="以太网数据帧"></a>以太网数据帧</h2><p>上面所有东西都准备好了，封装发送的其实是以太网数据帧。以太网目的地址、以太网源地址、帧类型这三者组成了帧首部。在首部之前还会插入前同步码和帧开始定界符，告知接收端做一些准备工作。帧检验序列 FCS被添加进尾部，用来检测帧是否出错。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><script>document.write('<img src="'+imgurl+'1736749038/e424cb9b1feddf997a6f61c80d80c77d.jpeg">')</script><br><p><strong>前同步码：</strong>协调终端接收适配器的时钟频率，让它与发送端频率相同。</p><p><strong>帧开始定界符：</strong>帧开始的标志，表示帧信息要来了，准备接收。</p><p><strong>目的地址：</strong>接收帧的网络适配器的MAC地址，接收端收到帧时，会首先检查目的地址与本机地址是否相符，不是的话就会丢弃。</p><p><strong>源地址：</strong>发送端设备的MAC地址。</p><p><strong>类型：</strong>决定接收到帧之后将数据交由那种协议处理。</p><p><strong>数据：</strong>交给上层的数据。在本文的场景中指IP数据报。</p><p><strong>帧检验序列：</strong>检测这一帧是否出错，发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。<br><strong>传输和接收</strong></p><ol><li>接收到上层传过来的数据报之后，根据MTU以及数据报大小来决定是否分割成小块，也就是IP数据报被分片的过程。</li><li>把数据报（块）封装成一帧，传给底层组件，底层组件将帧转换为比特流，并发送出去。</li><li>以太网上的设备接收到帧，检查帧里边的目标地址，如果与本机地址匹配，帧就会被处理，一层一层向上传递（分用过程）。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一个网络请求从源端一层层封装，再到终端一层层拆分，最后的所有过程基本梳理清楚，文章只是简单梳理了一下大概流程，并且只以HTTP报文通过TCP协议经过IP传送这一过程为例，实际还有很多概念没有覆盖，比如链路层的尾部封装、 IP的动态选路、逆地址解析协议RARP、UDP协议相关的概念，建议大家可以阅读下面列出的参考资料，相信会有更多收获。</p><div id="post-outdate-notice" data="{&quot;limitDay&quot;:1095,&quot;messagePrev&quot;:&quot;距离上次更新已经过去了&quot;,&quot;messageNext&quot;:&quot;天，文章可能已经过时。&quot;,&quot;postUpdate&quot;:&quot;2025-01-18 21:14:26&quot;}" hidden></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://blxtcloud.github.io">避凉闲庭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://blxtcloud.github.io/2025/01/13/2025011310/">https://blxtcloud.github.io/2025/01/13/2025011310/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blxtcloud.github.io" target="_blank">避凉闲庭</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/">云计算</a></div><div class="post-share"><div class="social-share" data-image="https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/24/2024122402/" title="ansible开局配置-openEuler"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">ansible开局配置-openEuler</div></div><div class="info-2"><div class="info-item-1">ansible干啥用的就不多介绍了，这篇文章主要在说ansible的安装、开局配置、免密登录。 ansible安装 查看系统版本 1cat /etc/openEuler-latest 输出内容如下： openeulerversion&#x3D;openEuler-24.03-LTS compiletime&#x3D;2024-05-27-21-31-28 gccversion&#x3D;12.3.1-30.oe2403 kernelversion&#x3D;6.6.0-28.0.0.34.oe2403 openjdkversion&#x3D;1.8.0.412.b08-5.oe2403 清除软件库缓存 1dnf clean all 建议软件库缓存 1dnf makecache 安装epel-release软件仓 下载对应版本epel-release的软件仓库 12# 不同系统版本需要安装不同的epel-releasewget...</div></div></div></a><a class="pagination-related" href="/2024/12/24/2024122404/" title="schedule-执行周期性任务"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">schedule-执行周期性任务</div></div><div class="info-2"><div class="info-item-1">模块介绍该模块主要用于python的任务调度，使用简便友好的python语法定期运行python函数或者一些其他的调用对象，这个模块就类似于windows的任务计划和linux的crontab，都是用于在服务器上周期性执行某段python脚本。 相较于linux的crontab对比： schedule模块支持以秒为单位的周期性任务，而crontab只能完成以分钟为单位的。 schedule模块当有很多个任务需要执行时管理起来很方便，直接内嵌到代码当中，crontab还需要每一个脚本去设置一次，增加了复杂度。 轻量级，无需任何依赖 模块安装123pip install schedule# pip3 安装pip3 install schedule 国内安装获取软件包可能会很慢，可以采用国内各大加速进行安装 123456# 清华大学源pip install schedule -i https://pypi.tuna.tsinghua.edu.cn/simple # 阿里云源pip install schedule -i...</div></div></div></a><a class="pagination-related" href="/2024/12/26/2024122607/" title="分享一款开源堡垒机-jumpserver"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-26</div><div class="info-item-2">分享一款开源堡垒机-jumpserver</div></div><div class="info-2"><div class="info-item-1">JumpServer是由FIT2CLOUD（飞致远）公司旗下一款开源的堡垒机，这款也是全球首款开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 规范的运维安全审计系统，使用 Python 开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 方案，交互界面美观、用户体验好，同时采纳分布式架构，支持多机房跨区域部署以及横向扩展，无资产数量及并发限制。这款开源堡垒机不但提供了社区开源版本并且还提供了企业使用的企业版本，企业版功能更加强大。 飞致远官网地址：https://www.fit2cloud.com/ 旗下开源软件： MeterSphere：是一站式开源持续测试平台, 涵盖测试跟踪、接口测试、性能测试、 团队协作等功能，全面兼容 JMeter、Postman、Swagger 等开源、主流标准，有效助力开发和测试团队充分利用云弹性进行高度可扩展的自动化测试，加速高质量的软件交付，推动中国测试行业整体效率的提升。 KubeOperator：是一个开源的轻量级 Kubernetes 发行版，专注于帮助企业规划、部署和运营生产级别的...</div></div></div></a><a class="pagination-related" href="/2024/12/28/2024122801/" title="Python实现AI图像识别-身份证识别"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">Python实现AI图像识别-身份证识别</div></div><div class="info-2"><div class="info-item-1">图像识别说白了就是把一张照片上面的文字进行提取，提供工作效率 需求分析身份证识别主要是把一张身份证照片上面的文字信息进行提取，不用再使用人工去手动抄写了，下面给大家说的这个身份识别主要是使用python+flask+华为云OCR进行实现的。 步骤 申请华为云OCR接口 获取token 调用身份证识别接口 提取身份证信息 申请华为云OCR接口图像识别主要使用的就是华为云OCR平台申请的接口，访问华为云,访问申请的地址后点击菜单栏中的“控制台”，点击后会进入登录页面。 document.write(''); document.write(''); 登录成功后进入控制台，依次单击“服务列表”-“人工智能”-“文字识别OCR” document.write(''); 进入后点击身份证识别后面的“开通服务”即可，（这里需要主要的是免费开通的身份证识别服务仅有1000次的免费调用次数，超过次数将会收费，建议购买套餐包，购买可以找我，我可以给优惠哦） document.write('');...</div></div></div></a><a class="pagination-related" href="/2024/12/28/2024122804/" title="IPV6改造 华为云如此简单"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">IPV6改造 华为云如此简单</div></div><div class="info-2"><div class="info-item-1">现在很多企业都在搞这个IPV6改造，说实话这个IPV6改造我这边也不是特别精通，也是通过查阅各种资料来了解IPV6这个东西，下面是我查的一些资料大家可以借鉴一下。 IPv6改造三步曲——Vecloud IPv6改造思路及CDN改造 企业应用IPv6改造方案.pdf docker nginx网站...</div></div></div></a><a class="pagination-related" href="/2025/01/13/2025011309/" title="云基础知识介绍及云组件部署"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-13</div><div class="info-item-2">云基础知识介绍及云组件部署</div></div><div class="info-2"><div class="info-item-1">云基础知识介绍及云组件部署序言随着业务的发展，各类业务都有上云的需求，大家在工作中也会经常遇到各类公有云的场景，其实各大厂商的公有云功能都大相径庭。相信很多人有疑问，如何在公有云上部署相关云组件和安全产品呢？本着共同学习的心态，耗时半月，才有了这篇文章，希望能让更多的伙伴们学习和掌握阿里云上的基本操作和部署组件。 本文分为两个篇章，基础知识篇和创建部署篇，来详细讲解。 基础知识篇 *阿里云简介：* 阿里巴巴旗下云计算品牌，创立于2009年，2010年，阿里云对外开放其在云计算领域的技术服务能力。用户通过阿里云，用互联网的方式即可远程获取海量计算、存储资源和大数据处理能力。 阿里云产品有那些？ 阿里云产品体系分为6大类，分别为：存储与内容分发服务、弹性计算服务、数据存储及计算服务、大规模计算服务、应用服务还有安全与管理服务。 和我们结合最紧密的产品为弹性计算服务，特别是云服务器（Elastic Compute...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://jihulab.com/blxt/images/-/raw/main/ico/head.jpg" onerror='this.onerror=null,this.src="https://jihulab.com/blxt/images/-/raw/main/ico/friend_404.gif"' alt="avatar"></div><div class="author-info-name">避凉闲庭</div><div class="author-info-description">一起学习，天天向上</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" href="https://blxtcloud.github.io/message/"><i class="fa-solid fa-message"></i><span>给我留言吧</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://blxtcloud.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:kuiyajia@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">该网站正在加速建设中</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7"><span class="toc-number">1.</span> <span class="toc-text">从一个经典的面试题说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%92%8C%E5%88%86%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">封装和分用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">分用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E5%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">逐层分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">7.</span> <span class="toc-text">HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">报文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E8%A1%8C"><span class="toc-number">9.</span> <span class="toc-text">起始行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">10.</span> <span class="toc-text">方法与状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E9%83%A8"><span class="toc-number">11.</span> <span class="toc-text">首部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93"><span class="toc-number">12.</span> <span class="toc-text">实体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-TCP"><span class="toc-number">13.</span> <span class="toc-text">传输层-TCP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-IP"><span class="toc-number">14.</span> <span class="toc-text">网络层-IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-number">15.</span> <span class="toc-text">路由选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">16.</span> <span class="toc-text">数据报分片的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%EF%BC%9AARP"><span class="toc-number">17.</span> <span class="toc-text">地址解析协议：ARP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">ARP分组格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="toc-number">19.</span> <span class="toc-text">以太网数据帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">20.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">21.</span> <span class="toc-text">最后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/2025011319/" title="nginx location匹配及rewrite规则">nginx location匹配及rewrite规则</a><time datetime="2025-01-13T07:17:14.000Z" title="发表于 2025-01-13 15:17:14">2025-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/2025011318/" title="resin部署安装">resin部署安装</a><time datetime="2025-01-13T06:51:30.000Z" title="发表于 2025-01-13 14:51:30">2025-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/2025011317/" title="docker命令总结（一）">docker命令总结（一）</a><time datetime="2025-01-13T06:49:25.000Z" title="发表于 2025-01-13 14:49:25">2025-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/2025011316/" title="docker命令总结（二）">docker命令总结（二）</a><time datetime="2025-01-13T06:47:27.000Z" title="发表于 2025-01-13 14:47:27">2025-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/2025011315/" title="制作网页黑白背景">制作网页黑白背景</a><time datetime="2025-01-13T06:43:29.000Z" title="发表于 2025-01-13 14:43:29">2025-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 避凉闲庭</div><div class="footer_custom_text"><span>欢迎来到避凉闲庭的博客，本博客主题采用</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script src="/js/downloads.js"></script><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="避,凉,闲,庭" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="python" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>